<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2020-12-02 Wed 16:24 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Let‚Äôs go write a Lisp ‚Äê part two</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Alan Third">
                     <link rel='stylesheet' type='text/css' href='/common/idiocy.css'>
                     <meta name='viewport' content='width=device-width, initial-scale=1.0'>
</head>
<body>
<div id="preamble" class="status">
                         <a href='/'>
                           <img src='/common/logo.svg' alt='idiocy.org'>
                         </a>
</div>
<div id="content">
<header>
<h1 class="title">Let‚Äôs go write a Lisp ‚Äê part two</h1>
</header><p>
This is the second part of an attempt to write a Lisp‚Äêlike language as
a meta‚Äêcircular evaluator in JavaScript. So far we‚Äôve got it taking in
a string and executing functions, but not much else. <a href="part-1.html">Here‚Äôs part one</a>.
</p>

<div id="outline-container-orge726da6" class="outline-2">
<h2 id="orge726da6">Variables</h2>
<div class="outline-text-2" id="text-orge726da6">
<p>
‚ÄòThat‚Äôs all well and good‚Äô, I hear you cry, ‚Äòbut what about variables?
How am I supposed to get <span class="underline">any</span> work done without being able to store
things?‚Äô
</p>

<p>
OK, so I guess we can add variables.
</p>

<p>
First of all we‚Äôll need somewhere to store them. Remember that object
that we put all our functions into? Let‚Äôs rename that <code>global</code>. For
convenience we‚Äôll create a <code>lispDefine</code> function that stores things in
it.
</p>

<p>
Finally we‚Äôll create a lookup function for retrieving the values. We
can use this in lispEval to do a look‚Äêup for all symbols.
</p>

<div class="org-src-container">
<pre class="src src-js" id="orgd93814a"><span style="color: #99968b;">/* </span><span style="color: #99968b;">Environment object.</span><span style="color: #99968b;"> */</span>
<span style="color: #8ac6f2; font-weight: bold;">const</span> <span style="color: #cae682;">global</span> = {}

<span style="color: #99968b;">/* </span><span style="color: #99968b;">A helper function for defining lisp variables.</span><span style="color: #99968b;"> */</span>
<span style="color: #8ac6f2; font-weight: bold;">function</span> <span style="color: #cae682;">lispDefine</span>(<span style="color: #cae682;">env</span>, <span style="color: #cae682;">name</span>, <span style="color: #cae682;">value</span>) {
  <span style="color: #8ac6f2; font-weight: bold;">if</span> (<span style="color: #8ac6f2; font-weight: bold;">typeof</span> name === <span style="color: #95e454;">"string"</span>) {
    env[Symbol.<span style="color: #8ac6f2; font-weight: bold;">for</span>(name)] = value
  }
  <span style="color: #8ac6f2; font-weight: bold;">else</span> <span style="color: #8ac6f2; font-weight: bold;">if</span> (<span style="color: #8ac6f2; font-weight: bold;">typeof</span> name === <span style="color: #95e454;">"symbol"</span>) {
    env[name] = value
  }
  <span style="color: #8ac6f2; font-weight: bold;">else</span> {
    <span style="color: #8ac6f2; font-weight: bold;">throw</span> <span style="color: #95e454;">"DEFINE: Unexpected type '"</span> + <span style="color: #8ac6f2; font-weight: bold;">typeof</span> name
      + <span style="color: #95e454;">"' for '"</span> + name + <span style="color: #95e454;">"'!"</span>
  }
}

<span style="color: #8ac6f2; font-weight: bold;">function</span> <span style="color: #cae682;">lookupVariable</span>(<span style="color: #cae682;">env</span>, <span style="color: #cae682;">name</span>) {
  <span style="color: #8ac6f2; font-weight: bold;">if</span> (env.hasOwnProperty(name)) {
    <span style="color: #8ac6f2; font-weight: bold;">return</span> env[name]
  }
  <span style="color: #8ac6f2; font-weight: bold;">else</span> {
    <span style="color: #8ac6f2; font-weight: bold;">throw</span> <span style="color: #95e454;">"LOOKUP: Unknown variable '"</span> + Symbol.keyFor(name) + <span style="color: #95e454;">"'!"</span>
  }
}

lispDefine(global, <span style="color: #95e454;">'display'</span>, <span style="color: #8ac6f2; font-weight: bold;">function</span>(...args) {
  console.log(args.join(<span style="color: #95e454;">' '</span>))
})

lispDefine(global, <span style="color: #95e454;">'+'</span>, <span style="color: #8ac6f2; font-weight: bold;">function</span>(...args) {
  <span style="color: #8ac6f2; font-weight: bold;">return</span> args.reduce((a, b) =&gt; a + b, 0)
})

lispDefine(global, <span style="color: #95e454;">'='</span>, <span style="color: #8ac6f2; font-weight: bold;">function</span>(...args) {
  <span style="color: #8ac6f2; font-weight: bold;">return</span> args.reduce((carry, x) =&gt; carry &amp; (args[0] === x), <span style="color: #e5786d;">true</span>)
})
</pre>
</div>

<div class="org-src-container">
<pre class="src src-js" id="org9f6ee8c"><span style="color: #8ac6f2; font-weight: bold;">function</span> <span style="color: #cae682;">lispEval</span>(<span style="color: #cae682;">item</span>) {
  <span style="color: #8ac6f2; font-weight: bold;">if</span> (<span style="color: #8ac6f2; font-weight: bold;">typeof</span> item === <span style="color: #95e454;">"symbol"</span>) {
    <span style="color: #8ac6f2; font-weight: bold;">return</span> lookupVariable(global, item)
  }
  <span style="color: #8ac6f2; font-weight: bold;">else</span> <span style="color: #8ac6f2; font-weight: bold;">if</span> (Array.isArray(item)) {
    <span style="color: #99968b;">/* </span><span style="color: #99968b;">Check if the function is an "if".</span><span style="color: #99968b;"> */</span>
    <span style="color: #8ac6f2; font-weight: bold;">if</span> (item[0] === Symbol.<span style="color: #8ac6f2; font-weight: bold;">for</span>(<span style="color: #95e454;">'if'</span>)) {
      lispIf(item.slice(1))
    }
    <span style="color: #99968b;">/* </span><span style="color: #99968b;">Or a "define".</span><span style="color: #99968b;"> */</span>
    <span style="color: #8ac6f2; font-weight: bold;">else</span> <span style="color: #8ac6f2; font-weight: bold;">if</span> (item[0] === Symbol.<span style="color: #8ac6f2; font-weight: bold;">for</span>(<span style="color: #95e454;">'define'</span>)) {
      lispDefine(global, item[1], lispEval(item[2]))
    }
    <span style="color: #8ac6f2; font-weight: bold;">else</span> {
      <span style="color: #99968b;">/* </span><span style="color: #99968b;">We must always eval the function name element of the array as</span>
<span style="color: #99968b;">       * we have no guarantee it's a function.</span><span style="color: #99968b;"> */</span>
      <span style="color: #8ac6f2; font-weight: bold;">const</span> <span style="color: #cae682;">f</span> = lispEval(item[0])

      <span style="color: #8ac6f2; font-weight: bold;">try</span> {
        <span style="color: #8ac6f2; font-weight: bold;">return</span> lispApply(f, item.slice(1))
      }
      <span style="color: #8ac6f2; font-weight: bold;">catch</span>(err) {
        <span style="color: #8ac6f2; font-weight: bold;">throw</span> err + <span style="color: #95e454;">"\nEVAL: Calling '"</span> + JSON.stringify(item[0]) + <span style="color: #95e454;">"'"</span>
      }
    }
  }
  <span style="color: #8ac6f2; font-weight: bold;">else</span> {
    <span style="color: #8ac6f2; font-weight: bold;">return</span> item
  }
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-js" id="orgbe54740">lispEval(parser(lexer(<span style="color: #95e454;">'(define cows "moo &#128004;")'</span>)))
lispEval(parser(lexer(<span style="color: #95e454;">'(display cows)'</span>)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-js">moo &#128004;
</pre>
</div>
</div>
</div>

<div id="outline-container-org5a27831" class="outline-2">
<h2 id="org5a27831">Functions</h2>
<div class="outline-text-2" id="text-org5a27831">
<p>
So far so good, but we have to write our functions in JavaScript,
which is OK, I guess, but not very exciting. Let‚Äôs make a <code>lambda</code>
function.
</p>

<p>
One thing we need to bear in mind is that we need to look up
variables, which could be either local to the function or global. To
save us having to do two look‚Äêups (local and global) for each variable
we‚Äôll build a data structure containing the local variables, and the
global environment object. Then we can modify <code>lookupVariable</code> to
check each in turn. (More recursion!)
</p>

<div class="org-src-container">
<pre class="src src-js" id="orgbb8e010"><span style="color: #99968b;">/* </span><span style="color: #99968b;">Make a new environment object.</span><span style="color: #99968b;"> */</span>
<span style="color: #8ac6f2; font-weight: bold;">function</span> <span style="color: #cae682;">newEnvironment</span>(<span style="color: #cae682;">parent</span>) {
  <span style="color: #8ac6f2; font-weight: bold;">const</span> <span style="color: #cae682;">e</span> = {}
  e.parent = parent
  <span style="color: #8ac6f2; font-weight: bold;">return</span> e
}

<span style="color: #99968b;">/* </span><span style="color: #99968b;">A helper function for defining lisp variables.</span><span style="color: #99968b;"> */</span>
<span style="color: #8ac6f2; font-weight: bold;">function</span> <span style="color: #cae682;">lispDefine</span>(<span style="color: #cae682;">env</span>, <span style="color: #cae682;">name</span>, <span style="color: #cae682;">value</span>) {
  <span style="color: #8ac6f2; font-weight: bold;">if</span> (<span style="color: #8ac6f2; font-weight: bold;">typeof</span> name === <span style="color: #95e454;">"string"</span>) {
    env[Symbol.<span style="color: #8ac6f2; font-weight: bold;">for</span>(name)] = value
  }
  <span style="color: #8ac6f2; font-weight: bold;">else</span> <span style="color: #8ac6f2; font-weight: bold;">if</span> (<span style="color: #8ac6f2; font-weight: bold;">typeof</span> name === <span style="color: #95e454;">"symbol"</span>) {
    env[name] = value
  }
  <span style="color: #8ac6f2; font-weight: bold;">else</span> {
    <span style="color: #8ac6f2; font-weight: bold;">throw</span> <span style="color: #95e454;">"DEFINE: Unexpected type '"</span> + <span style="color: #8ac6f2; font-weight: bold;">typeof</span> name
          + <span style="color: #95e454;">"' for '"</span> + name + <span style="color: #95e454;">"'!"</span>
  }
}

<span style="color: #8ac6f2; font-weight: bold;">function</span> <span style="color: #cae682;">lookupVariable</span>(<span style="color: #cae682;">env</span>, <span style="color: #cae682;">name</span>) {
  <span style="color: #8ac6f2; font-weight: bold;">if</span> (env.hasOwnProperty(name)) {
    <span style="color: #8ac6f2; font-weight: bold;">return</span> env[name]
  }
  <span style="color: #8ac6f2; font-weight: bold;">else</span> <span style="color: #8ac6f2; font-weight: bold;">if</span> (env.parent !== <span style="color: #e5786d;">null</span>) {
    <span style="color: #99968b;">/* </span><span style="color: #99968b;">Look it up in the parent environment.</span><span style="color: #99968b;"> */</span>
    <span style="color: #8ac6f2; font-weight: bold;">return</span> lookupVariable(env.parent, name)
  }
  <span style="color: #8ac6f2; font-weight: bold;">else</span> {
    <span style="color: #8ac6f2; font-weight: bold;">throw</span> <span style="color: #95e454;">"LOOKUP: Unknown variable '"</span> + Symbol.keyFor(name) + <span style="color: #95e454;">"'!"</span>
  }
}

<span style="color: #8ac6f2; font-weight: bold;">const</span> <span style="color: #cae682;">global</span> = newEnvironment(<span style="color: #e5786d;">null</span>)
</pre>
</div>

<p>
We‚Äôll use a closure to contain the lisp code within a JavaScript
function. This means we don‚Äôt have to differentiate between JavaScript
and lisp functions within <code>lispApply</code> because they‚Äôre all just
JavaScript functions!
</p>

<div class="org-src-container">
<pre class="src src-js" id="org8ce7be7"><span style="color: #8ac6f2; font-weight: bold;">function</span> <span style="color: #cae682;">lambda</span>(<span style="color: #cae682;">env</span>, <span style="color: #cae682;">argnames</span>, <span style="color: #cae682;">body</span>) {
  <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #8ac6f2; font-weight: bold;">function</span>(...args) {
    <span style="color: #99968b;">/* </span><span style="color: #99968b;">We need to build up a stack frame for this function where we</span>
<span style="color: #99968b;">     * store local variables, eg. the arguments.</span><span style="color: #99968b;"> */</span>
    <span style="color: #8ac6f2; font-weight: bold;">const</span> <span style="color: #cae682;">localEnv</span> = newEnvironment(env)

    <span style="color: #99968b;">/* </span><span style="color: #99968b;">For each arg, a, define a variable named argnames[i].</span><span style="color: #99968b;"> */</span>
    args.forEach((a, i) =&gt; lispDefine(localEnv, argnames[i], a))

    <span style="color: #99968b;">/* </span><span style="color: #99968b;">And eval each expression in the body with our new environment.</span>
<span style="color: #99968b;">     *</span>
<span style="color: #99968b;">     * TODO: add a begin function and use it here.</span><span style="color: #99968b;"> */</span>
    <span style="color: #8ac6f2; font-weight: bold;">return</span> body.reduce((c, s) =&gt; lispEval(localEnv, s), <span style="color: #e5786d;">null</span>)
  }
}
</pre>
</div>

<p>
Add environment handling to our other functions.
</p>

<div class="org-src-container">
<pre class="src src-js" id="org5ec8de2"><span style="color: #8ac6f2; font-weight: bold;">function</span> <span style="color: #cae682;">lispIf</span>(<span style="color: #cae682;">env</span>, <span style="color: #cae682;">args</span>) {
  <span style="color: #99968b;">/* </span><span style="color: #99968b;">Test argument 0 and evaluate argument 1 or 2 as appropriate.</span><span style="color: #99968b;"> */</span>
  <span style="color: #8ac6f2; font-weight: bold;">if</span> (lispEval(env, args[0])) {
    <span style="color: #8ac6f2; font-weight: bold;">return</span> lispEval(env, args[1])
  }
  <span style="color: #99968b;">// </span><span style="color: #99968b;">else</span>
  <span style="color: #8ac6f2; font-weight: bold;">return</span> lispEval(env, args[2])
}

<span style="color: #8ac6f2; font-weight: bold;">function</span> <span style="color: #cae682;">lispApply</span>(<span style="color: #cae682;">env</span>, <span style="color: #cae682;">f</span>, <span style="color: #cae682;">args</span>) {
  <span style="color: #8ac6f2; font-weight: bold;">if</span> (<span style="color: #8ac6f2; font-weight: bold;">typeof</span> f !== <span style="color: #95e454;">"function"</span>) {
    <span style="color: #8ac6f2; font-weight: bold;">throw</span> <span style="color: #95e454;">"APPLY: Unknown function!"</span>
  }

  <span style="color: #8ac6f2; font-weight: bold;">const</span> <span style="color: #cae682;">a</span> = args.map((a) =&gt; lispEval(env, a))
  <span style="color: #8ac6f2; font-weight: bold;">return</span> f.apply(<span style="color: #e5786d;">null</span>, a)
}
</pre>
</div>

<p>
And finally add environment handling to <code>lispEval</code> too, and because
<code>lambda</code> is another special form we add it to <code>lispEval</code>. The
arguments shouldn‚Äôt be evaluated, otherwise the function would be
evaluated when we declare it instead of when we call it.
</p>

<div class="org-src-container">
<pre class="src src-js" id="orgcb43dd3"><span style="color: #8ac6f2; font-weight: bold;">function</span> <span style="color: #cae682;">lispEval</span>(<span style="color: #cae682;">env</span>, <span style="color: #cae682;">item</span>) {
  <span style="color: #8ac6f2; font-weight: bold;">if</span> (<span style="color: #8ac6f2; font-weight: bold;">typeof</span> item === <span style="color: #95e454;">"symbol"</span>) {
    <span style="color: #8ac6f2; font-weight: bold;">return</span> lookupVariable(env, item)
  }
  <span style="color: #8ac6f2; font-weight: bold;">else</span> <span style="color: #8ac6f2; font-weight: bold;">if</span> (Array.isArray(item)) {
    <span style="color: #99968b;">/* </span><span style="color: #99968b;">Check if the function is an "if".</span><span style="color: #99968b;"> */</span>
    <span style="color: #8ac6f2; font-weight: bold;">if</span> (item[0] === Symbol.<span style="color: #8ac6f2; font-weight: bold;">for</span>(<span style="color: #95e454;">'if'</span>)) {
      <span style="color: #8ac6f2; font-weight: bold;">return</span> lispIf(env, item.slice(1))
    }
    <span style="color: #99968b;">/* </span><span style="color: #99968b;">Or a "define".</span><span style="color: #99968b;"> */</span>
    <span style="color: #8ac6f2; font-weight: bold;">else</span> <span style="color: #8ac6f2; font-weight: bold;">if</span> (item[0] === Symbol.<span style="color: #8ac6f2; font-weight: bold;">for</span>(<span style="color: #95e454;">'define'</span>)) {
      lispDefine(env, item[1], lispEval(env, item[2]))
    }
    <span style="color: #99968b;">/* </span><span style="color: #99968b;">Or "lambda"...</span><span style="color: #99968b;"> */</span>
    <span style="color: #8ac6f2; font-weight: bold;">else</span> <span style="color: #8ac6f2; font-weight: bold;">if</span> (item[0] === Symbol.<span style="color: #8ac6f2; font-weight: bold;">for</span>(<span style="color: #95e454;">'lambda'</span>)) {
      <span style="color: #8ac6f2; font-weight: bold;">return</span> lambda(env, item[1], item.slice(2))
    }
    <span style="color: #99968b;">/* </span><span style="color: #99968b;">Or "quote". (Return the argument unmodified.)</span><span style="color: #99968b;"> */</span>
    <span style="color: #8ac6f2; font-weight: bold;">else</span> <span style="color: #8ac6f2; font-weight: bold;">if</span> (item[0] === Symbol.<span style="color: #8ac6f2; font-weight: bold;">for</span>(<span style="color: #95e454;">'quote'</span>)) {
      <span style="color: #8ac6f2; font-weight: bold;">return</span> item[1]
    }
    <span style="color: #8ac6f2; font-weight: bold;">else</span> {
      <span style="color: #8ac6f2; font-weight: bold;">try</span> {
        <span style="color: #8ac6f2; font-weight: bold;">return</span> lispApply(env, lispEval(env, item[0]), item.slice(1))
      }
      <span style="color: #8ac6f2; font-weight: bold;">catch</span>(err) {
        <span style="color: #8ac6f2; font-weight: bold;">throw</span> err + <span style="color: #95e454;">"\nEVAL: Calling '"</span> + JSON.stringify(item[0]) + <span style="color: #95e454;">"'"</span>
      }
    }
  }
  <span style="color: #8ac6f2; font-weight: bold;">else</span> {
    <span style="color: #8ac6f2; font-weight: bold;">return</span> item
  }
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-js" id="org0203997">lispEval(global, parser(lexer(<span style="color: #95e454;">'(define cows (lambda (x) (display "cows" x "moo &#128004;")))'</span>)))
lispEval(global, parser(lexer(<span style="color: #95e454;">'(cows "go")'</span>)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-js">cows go moo &#128004;
</pre>
</div>

<p>
Looks good. Let‚Äôs try something more complex.
</p>

<div class="org-src-container">
<pre class="src src-js" id="org46ecd1e"><span style="color: #8ac6f2; font-weight: bold;">const</span> <span style="color: #cae682;">sexp</span> = <span style="color: #95e454;">`</span>
<span style="color: #95e454;">  (define fib (lambda (n)</span>
<span style="color: #95e454;">    (define iter (lambda (a b count)</span>
<span style="color: #95e454;">                   (if (= n count)</span>
<span style="color: #95e454;">                       (+ a b)</span>
<span style="color: #95e454;">                       (iter b (+ a b) (+ count 1)))))</span>
<span style="color: #95e454;">    (iter 1 1 3)))</span>
<span style="color: #95e454;">`</span>

lispEval(global, parser(lexer(sexp)))
lispEval(global, parser(lexer(<span style="color: #95e454;">'(display "The 12th Fibonacci number is:" (fib 12))'</span>)))
</pre>
</div>

<p>
The 12th Fibonacci number is 144. Let‚Äôs see what we get&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-js">The 12th Fibonacci number is: 144
</pre>
</div>

<p>
Wooo!
</p>

<p>
It may not be immediately obvious, but our lisp has lexical scope and
you can use closures. This is because we‚Äôre passing <code>lambda</code> the
environment of the calling function and it‚Äôs stored within the
JavaScript closure that <code>lambda</code> creates, just like the program code
itself.
</p>
</div>
</div>

<div id="outline-container-orgce1355b" class="outline-2">
<h2 id="orgce1355b">REPL(ish)</h2>
<div class="outline-text-2" id="text-orgce1355b">
<p>
I‚Äôve hacked together a rather dodgy REPL.
</p>

<p>
I‚Äôve added some more functions:
</p>

<dl class="org-dl">
<dt>Arithmetic</dt><dd>+, -, *, /, <code>, &gt;, &lt;, &gt;</code>, &lt;=, %</dd>
<dt>Boolean arithmetic</dt><dd>and, or, not</dd>
<dt>Array handling</dt><dd>first, rest, push, pop, shift, unshift, array-ref,
concat</dd>
<dt>Strings</dt><dd>split (no need for join as you can use ‚Äô+‚Äô for that)</dd>
<dt>Flow control</dt><dd>map, reduce</dd>
<dt>Others</dt><dd>null (returns null, shockingly), get-js-context (you can
use this to get JavaScript functions)</dd>
</dl>

<p>
The complete code is <a href="https://gist.github.com/alanthird/e2009725b0c0eccde6961fc77606b6a5">here</a>, and you can try it out below.
</p>

<style>
 #output {
     height: 10em;
     overflow: auto;
 }
</style>



<textarea id="input">
(display "Hello, world! üåç")
</textarea>
<br>
<input type="button" id="runIt" value="Eval">
<br>
<pre id="output"></pre>

<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.18.2/codemirror.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.18.2/codemirror.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.18.2/theme/zenburn.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.18.2/mode/scheme/scheme.min.js"></script>

<script src="part-2.js"></script>
</div>
</div>
</div>
<div id="postamble" class="status">
                          <table>
                              <tr>
                                  <th>t</th>
                                  <td><a href='https://twitter.com/flxzr'>@flxzr</a></td>
                              </tr>
                              <tr>
                                  <th>g</th>
                                  <td><a href='https://github.com/alanthird'>alanthird</a></td>
                              </tr>
                              <tr>
                                  <th>e</th>
                                  <td><a href='mailto:alan@idiocy.org'>Alan Third</a></td>
                              </tr>
                          </table>
</div>
</body>
</html>
